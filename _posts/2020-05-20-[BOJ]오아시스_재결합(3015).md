---
comments: true
layout: posts
title:  "[BOJ] 오아시스 재결합(3015)"
date:   2020-05-17 10:15:06 +0900
categories: markdown
---
## 문제 링크 : [[BOJ] 오아시스 재결합(3015)](https://www.acmicpc.net/problem/3015)

---

## 문제 설명
N개의 숫자가 차례로 주어지고, 두 개의 수를 골랐을 때, 두 수 사이에 두 수보다 큰 수가 없는 경우의 수를 구한다.

---

## 입력
N(줄을 선 사람의 수, 1<=N<=500,000)  
D<sub>i</sub>(N개가 나옴,1<=D<sub>i</sub><2<sup>32</sup>)  
```
7
2
4
1
2
2
5
1
```
---
## 출력
경우의 수
```
10
```

---

## 카테고리  
#Stack

---

## 시간 복잡도 상한
N이 50만이므로, N<sup>2</sup>이면 타임아웃이 난다.  
최대 O(NlogN)에 끝내야 한다.

---
## 해결 방법
1. 다음 조건이 만족함을 확인한다.  
    a. D<sub>a</sub>가 D<sub>b</sub>(a<b)보다 작다면 D<sub>a</sub>는 D<sub>b</sub> 이후에 짝을 찾을 수 없다.  
    ![사진](/assets/img/3015/1.png)

b.
---

## 코드

```cpp
#include<cstdio>
int n,m,d[300001],i,a,b,v[300001];
int f(int a){
    if(a==d[a])return a;
    return d[a]=f(d[a]);
}
void u(int a,int b){
    d[f(a)]=f(b);
}
int main(){
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++)d[i]=i,v[i]=1;
    while(n--){
        scanf("%d%d",&a,&b);
        int fa=f(a);
        int fb=f(b);
        if(v[fa]>0||v[fb]>0)printf("LADICA\n");
        else printf("SMECE\n");
        
        if(fa==fb){
            if(v[fa])v[fa]--;
        }else{
            u(a,b);
            v[fb]=v[fa]+v[fb]-1;
        }
    }
}
```
